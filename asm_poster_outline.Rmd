```{r requirements, echo = FALSE, message=FALSE, results='hide'}
##  Initial data processing 
#loading required packages and sourcing files
library(ggplot2)
library(stringr)
library(reshape2)
library(plyr)
library(xtable)
source("purity_functions.R")
source("file_locations.R")
source("match_tid.R")
```

```{r load-data, echo = FALSE, message=FALSE, results='hide'}
#removing unused columns
clean_match_df <- function(match_df){
  return(subset(match_df, select = -c(Final.Best.Hit, 
                                      Final.High.Confidence.Hits, 
                                      Final.Low.Confidence.Hits, 
                                      Initial.Guess, 
                                      Initial.Best.Hit, 
                                      Initial.Best.Hit.Read.Numbers, 
                                      Initial.High.Confidence.Hits, 
                                      Initial.Low.Confidence.Hits)))
}

#loading single organisms datasets
single_matches <- read.csv(str_c(path_results_directory,c("/sim_single_matches.csv"), sep=""), stringsAsFactors = F)
single_matches$match <- factor(single_matches$match, levels = c("exact", "species", "genus","family","order","class", "phylum","no match"))
single_matches <- clean_match_df(single_matches)


#loading simualted contaminant datasets
contam_matches <- read.csv(str_c(path_results_directory,"/sim_contam_matches.csv", sep=""), stringsAsFactor = F)
for(i in c("org1_tid","org2_tid","size")){
  contam_matches[,i] <- as.factor(contam_matches[,i])
}
contam_matches <- clean_match_df(contam_matches)
```

```{r org_names, echo=FALSE, message=FALSE, cache=TRUE, results='hide'}
# Getting organsim and name and genus for matches and single organisms
org_df <- genusNameTable(unique(single_matches$org_tid))
single_matches <- join(single_matches, org_df)
single_matches <- rename(single_matches, c("name" = "target_name",
                                           "genus" = "target_genus"))

org_match_df <- genusNameTable(unique(c(contam_matches$match_tid, single_matches$match_tid)))
org_match_df <- rename(org_match_df,replace = c("org_tid" = "match_tid",
                                                 "name" = "match_name",
                                                 "genus" = "match_genus"))
contam_matches <- join(contam_matches, org_match_df)
single_matches <- join(single_matches, org_match_df)
```

```{r genus-table, results='hide', echo=FALSE, message=FALSE}
#modifying org_df for single dataset genus summary table
org_table <- dcast(org_df, genus~.)
colnames(org_table) <- c("Genus", "Total Strains")
org_table$Genus <- as.character(org_table$Genus)
org_table2 <- rbind(org_table, c(Genus = "Total", Strains = sum(org_table$Strains)))
```

```{r proportions, echo=FALSE, message=FALSE, results='hide'}
## contaminat proportions - for text
proportions <- str_c(unique(contam_matches$prop1),signif(1 - unique(contam_matches$prop1),2), sep = ":")
```

```{r sim-unique-counts, echo=FALSE, message=FALSE, results='hide'}
## Summary of single dataset match counts
sim_unique_counts <- ddply(contam_matches, .(org1_tid, size), summarize, count = length(unique(match_tid)))
sim_unique_counts$name <- single_matches$name[match(sim_unique_counts$org1_tid, single_matches$org_tid)]
sim_unique_counts$genus <- single_matches$genus[match(sim_unique_counts$org1_tid, single_matches$org_tid)]
```

```{r filtered-contam, echo=FALSE, message=FALSE, results='hide', cache=TRUE}
## Removing hit to single organisms from contam matches dataset
baseline_df <-  single_matches[single_matches$size == 250 & single_matches$org %in% unique(contam_matches$org1),] 
contam_filtered_250 <- filter_noise(contam_matches[contam_matches$size == 250,])
org_df$org2_tid <- org_df$org_tid
contam_filtered_250 <- join(contam_filtered_250, org_df)
contam_filtered_250 <- rename(contam_filtered_250, replace = c("name" = "contam_name",
                                                               "genus" = "contam_genus"))
contam_filtered_250$match_genus <- factor(contam_filtered_250$match_genus, 
                                          levels = c(levels(contam_filtered_250$match_genus),
                                                     "unc. Enterobacteriaceae"))
contam_filtered_250$match_genus[contam_filtered_250$match_tid == 693444] <- "unc. Enterobacteriaceae"
```

```{r single_counts_df, echo=FALSE, message=FALSE,results='hide'}
  single_counts <- ddply(single_matches, 
                         .(org_tid, target_genus, size), 
                         summarize, 
                         genus_count = length(unique(match_genus)), 
                         tid_counts = length(unique(match_tid)))
  single_counts <- melt(single_counts,id.vars=c("org_tid", "target_genus", "size"))
  single_counts$size <- as.factor(single_counts$size)
```

```{r org-labels, echo=FALSE, message=FALSE,results='hide'}
contam_names <- org_df[org_df$org_tid %in% as.character(unique(contam_matches$org2_tid)),]
contam_names$ab_names <- c("S. aureus", "F. tularensis","Y. pestis","S. enterica LT2", "B. anthracis", "P. aeruginosa", "E. coli")
ab_name_order <- c("B. anthracis",  "E. coli", "F. tularensis", "P. aeruginosa", "S. enterica", "S. aureus","Y. pestis" ) 
contam_names$ab_names <- factor(contam_names$ab_names,levels=ab_name_order)

# adding strain names to org_table2
org_table2[,"Representative Strain"] <- contam_names$name[match(org_table2$Genus, contam_names$genus)]
```

```{r org-tid-labeller, echo=FALSE, message=FALSE, results='hide'}
# this function is not working properly
org_names_list <- as.list(setNames(contam_names$ab_names,contam_names$org_tid))
#org_names_list <- contam_names$ab_names
#names(org_names_list) <- contam_names$org_tid
org_tid_labeller <- function(variable,value){
  return(org_names_list[value])
}
```

```{r contam_counts_df, echo=FALSE, message=FALSE}
contam_counts <- ddply(contam_filtered_250, 
                       .(org1_tid, org2_tid, match_genus), 
                       summarize, 
                       counts =length(unique(match_tid)))
contam_counts$org2_name <- contam_names$ab_name[match(as.character(contam_counts$org2_tid),as.character(contam_names$org_tid))]
contam_counts$org2_name <- factor(contam_counts$org2_name,levels=ab_name_order)
contam_counts$org1_name <- contam_names$ab_name[match(as.character(contam_counts$org1_tid),as.character(contam_names$org_tid))]    
contam_counts$org1_name <- factor(contam_counts$org1_name,levels=ab_name_order)
```

```{r contam_LOD_df, echo=FALSE, message=FALSE}
contam_genus_match <- contam_filtered_250[as.character(contam_filtered_250$match_genus) == as.character(contam_filtered_250$contam_genus),]
contam_genus_match <- contam_genus_match[!is.na(contam_genus_match$Genome),]
contam_genus_match$org1_name <- contam_names$ab_name[match(as.character(contam_genus_match$org1_tid),as.character(contam_names$org_tid))]    
contam_genus_match$org1_name <- factor(contam_genus_match$org1_name,levels=ab_name_order)
```

Outline for ASM poster on validating test material purity
========================================================
# Header
## Title   
Development of methods for using the pathoscope sequence analysis software to validate microbial test material purity.

## Authors  
Nathan D. Olson    
Justin Zook    
Jayne Morrow    
Nancy Lin 

## Author Affiliation  
Biosystems and Biomaterials Division, National Institute of Standards and Technology     

## Contact  
email nolson@nist.gov

# Abstract
Method validation for biodetection technologies requires high purity test materials.  Traditional methods for evaluating test material purity, e.g. polymerase chain reaction (PCR), require prior knowledge of the contaminant identity and have a limited level of detection (LOD).  Whole genome sequencing using next generation sequencing (NGS) technology addresses these limitations by providing a non-target specific approach and a lower LOD due to the large number of reads generated in a sequencing run – ten thousand to over one million reads.  Here we present a novel application of the pathoscope sequence analysis program (http://sourceforge.net/projects/pathoscope/) coupled with an expanded reference dataset to evaluate test material purity and validate material identity using simulated whole genome sequencing datasets.  To evaluate the ability of pathoscope to identify contaminants in test materials, in silico generated datasets for `r length(unique(single_matches$input_filename))` organisms from `r length(unique(org_df$genus))` different genera (`r str_c(unique(org_df$genus)[-length(unique(org_df$genus))], collapse = ", ")` and `r unique(org_df$genus)[length(unique(org_df$genus))]`).   First, the results from the analysis of the single organism datasets using pathoscope served as a baseline for the simulated contaminat analysis. Simulated datasets of 250 bp paried end reads with reads classified at the genus level provided suitable levels of specificity to identify potential test material contaminants.  To determine the method LOD, simulated reads from `r length(unique(contam_matches$org2))` were mixed at known proportions. All contaminant organisms excluding B. anthracis amd F. tularensis were detected at 0.05 % for all but 5 of the 29 the simulated test materials.  The detection levels for B. anthracis amd F. tularensis ranged between 5 % down to 0.25 %.  The approach presented here provides a sample independent, highly sensitive, and specific method for evaluating test material purity.  With the rapid decrease in NGS costs, this approach is a viable alternative to PCR based methods for evaluating test material purity and can be applied in a high throughput manner for screening panels of test materials.   

# Introduction
define test materials   
what are they used for   
why test materials should be pure 
There are a number of potential sources for contamination of test materials with other microorganisms, including the stock culture, the preservation medium, as well as airborne and laboratory contaminants.   

Current methods for evaluating test material purity include PCR-based assays, metagenomics, and whole genome sequencing based approaches.  One PCR assay was developed to analyze protist cultures.  This PCR assay uses endpoint PCR for prokaryotes and eukaryotes with template dilutions [9].  The benefit to PCR-based approaches is that they can be cost effective and fast if an applicable protocol exists.   However, PCR assays can only target specific contaminants.  While PCR based assays can detect contaminants, this approach does not scale effectively for multiple, potentially unknown contaminants and test materials.   
The bioinformatics tools developed to identify contaminants in metagenomic datasets, which include sequencing data from all organisms in a sample, can also be used to evaluate test material purity.  For example DeconSeq [10] and a similar method QC-Chain [11] were developed to identify contaminants based on analysis of 16S ribosomal ribonucleic acid (rRNA) gene sequences or comparison of a subset of reads to a reference database using Basic local alignment search tool (BLAST).  Metagonomic-based methods such as these are able to identify contaminants without any prior knowledge or assumptions regarding the identity of the organism(s).  However, methods based on 16S rRNA gene identification have limited resolution, as 16S rRNA sequences can only provide genus level taxonomic resolution at best.  Methods using BLAST-based searches represent a broader scale approach but are limited by the accuracy of the BLAST classification method.   The benefit to using tools developed for metagenomics is that prior knowledge of the identity of the contaminant is not required; however this method is unable to identify contaminants to the strain level.   
Another approach to evaluating test material purity is through shotgun whole genome sequencing, which attempts to sequence all DNA in a sample.  A recently published bioinformatics method, pathoscope, was developed to detect pathogens and identify strains using whole genome sequencing data.  This method benefits from the large sample size obtained using next generation sequencing for higher sensitivity and leverages algorithm advances for whole genome sequence mapping.  Mapping algorithms determine the optimal placement of reads relative to a reference sequence.  Reads are either uniquely or ambiguously mapped.  For uniquely mapped reads only a single optimal mapping location is identified, whereas for ambiguously mapped reads multiple optimal mapping locations are identified.  Pathoscope uses the number of reads that uniquely map to different genomes in the reference database to assign ambiguously mapped reads, reads that align equally well to multiple reference sequences.  The primary benefits to the shotgun whole genome sequencing and subsequent pathoscope analysis approach are that prior knowledge of the contaminant is not required and it can potentially identify the contaminant to the strain level.  However, the main limitation to this method is the size of the reference database, namely that the genome of the contaminant or a closely related organism must be present in the database for the contaminant to be detected.
Robust approaches to measure purity of microbial test materials used to validate biodetection assays will provide an increased confidence in the results from those assays.  In this work, we developed a novel method to measure the purity of single organism test materials.  This method is based on whole genome sequencing and utilizes pathoscope with an expanded reference database [12].  We will first present the specificity of the method using simulated data for single organisms.  Then, we evaluated the limit of detection of the method using simulated datasets generated to represent test materials contaminated at various proportions.  

# Methods
This bioinformatics approach to measuring test material purity consists of three steps: 1. Sequencing reads are generated for the test material using shotgun sequencing. 2. The reads are mapped to a reference database. For this step individual reads are aligned to all possible locations in the genomes in the reference database.   We generated a more exhaustive database compared to the pathoscope database including all prokaryotic organisms in the Genbank database (http://www.ncbi.nlm.nih.gov/genbank/, accessed 10/18/2013). 3. The resulting mapping file is processed with pathoscope to assess dataset composition [12]. For the mapping step the bwa mem mapping algorithm was used (http://bio-bwa.sourceforge.net).  This algorithm is capable of mapping reads to reference databases greater than 4 Gb in size.  The reference dataset included the chromosomes and plasmids for 2,709 bacterial genomes, including the strains used to validate the procedure.  Additionally, bwa mem can output all possible alignments for ambiguously mapped reads.  

To evaluate the specificity and sensitivity of the approach, simulated single organism as well as contaminated datasets (mixtures of two organisms) were generated.  The organisms used in the study included common foodborne human pathogens and biothreat agents (Table 1).  Simulated datasets were generated using the ART sequencing read simulator [13].  The ART simulator used error models based on real sequence datasets to generate more realistic datasets.  The datasets were generated using the Illumina error models with paired end 75 and 250 base pair reads and 20 X mean coverage for each of the strains [13].

Simulated whole genome sequencing datasets for `r length(unique(single_matches$input_filename))` organisms from  `r length(unique(org_df$genus))` different genus (Table 1) were used to evaluate the method specificity. Datasets from the individual organisms were mapped to the all-bacterial genomes database using bwa mem.  The resulting mapping file was processed using pathoscope. 
```{r genus-xtable, results='asis', echo=FALSE}
print(xtable(org_table2),type='html')
```

To evaluate the method sensitivity, simulated datasets with a target strain and a contaminant strain were generated and evaluated.  The reads in the datasets were subsampled in the following proportions:`r proportions[-1]` and `r proportions[length(proportions)]` where the first number represents the percentage of reads randomly selected from the target organism dataset and the second number represents the number of reads randomly selected from the contaminant dataset.  For example, a proportion of 0.5:0.5, the combined dataset included a random subsampling of 50 % of the reads from the target organism dataset and 50 % of the reads from the contaminant organism dataset.  Datasets were generated for all pairwise comparisons so that each of the six organisms was both a contaminant and target organism for all possible combinations at all `r length(proportions)` proportions, for a total of `r length(unique(contam_matches$input_filename))`  combinations.  The individual organism datasets vary in the number of reads in the due to differences in genome size, such that 50 % of one dataset will be a different absolute number of reads than 50 % of another dataset.   
To generate the simulated mapping datasets, the mapping files for the individual organisms were merged using samtools (http://samtools.sourceforge.net).  The resulting merged data files were downsampled to obtain the appropriate proportions of reads for each of the `r length(unique(contam_matches$input_filename))` combinations using an in-house python script.  The resulting simulated contaminated datasets were processed using pathoscope, and the output files were analyzed to determine the limit of detection of the methods using the statistical programing language R [14].

All of the scripts used in the study are available at https://github.com/nate-d-olson/genomic_purity. 

# Results and Discussion
## Specificity    
The single organism datasets to assess the method specificity.  Here specificity is defined as the methods ability to assign the reads to the appropriate organism.   
```{r single-counts-plot, echo=FALSE, fig.width = 10}
#need to order x axis species - genus
ggplot(single_counts) + 
  geom_boxplot(aes(x = variable, y= value, color = size)) + 
  facet_grid(~target_genus) +
  scale_x_discrete(breaks = levels(single_counts$variable), 
                       labels = c("Genus", "Strain")) +
  labs(x = "Match Level", y = "Number of unqiue hits", color = "Size (bp)")+
  theme_bw() +
  theme(strip.text.x = element_text(face="italic"))
```

For all organisms the number of both strain and genus matches decreases with increase in the length of the simulated reads (Fig. 1). The number of matches is dependent on the genetic diversity of the genomes within the genus in the database. Genus with greater diversity have fewer unique hits as fewer reads map incorectly to other genomes. The number of unique genus level matches for 250 bp simulated datasets provide a level of specificty that will allow for detection of contaminants in test materials with 99 % of target organisms having `r quantile(single_counts$value[single_counts$size == 250 & single_counts$variable == "genus_count"],probs=0.99)` or few unique genus level matches.   
  

```{r single-specificity-plot, echo=FALSE}
ggplot(single_counts[single_counts$size == 250,]) + 
  geom_density(aes(x = value, fill = variable), alpha = 0.25) +
  labs(x = "Numer of unique counts", 
       y = "Proportion of Total Counts", 
       fill = "Match Level") +
  theme_bw() 
```

Only a few reads were mapped to a majority of the sequences in the database (Fig 2). The estimated proportion of reads in the datasets mapped to a genome in the database 90 % have an estimated proportion less than `r quantile(single_matches$Final.Guess, probs= 0.90)`.  Most of the reads are mapped to the match organisms genome in the reference database (Fig 3). 

```{r final_guess_plot, echo=FALSE, message=FALSE}
qplot(x = Final.Guess, data = single_matches, geom= "bar") + scale_x_log10() + theme_bw() + labs(x = "Estimated Proportions", y = "Abundance")
```
```{r final_guess_exact_plot, echo=FALSE, message=FALSE}
#for exact matches only
qplot(x = Final.Guess, data = single_matches[single_matches$match == "exact",], geom= "bar") + scale_x_log10() + theme_bw() + labs(x = "Estimated Proportions", y = "Abundance")
```

## Sensitivity
The sensitivity of the method was evaluated by the methods ability to detect the in silico contaminants spiked in at different proportions.  Sensitivity was assessed for 250 bp reads and the genus of the reference sequence the mapped reads were assigned to.  Species and strain level evaluation of the matches for the 250 bp and all match levels for the 75 bp datasets- the specificity of the method was too low and therefore challenging to differentiate the noise from the contaminant signal.  To reduce the level of background noise hits to sequences for the single organism datasets for the test material strains were removed from the results for the contaminated datasets. For all contaminated test material datasets only the test material organims and contaminant were detected for the 250 bp datasets when evaluated at the genus level excluding E. coli (Fig. 4).  The different simulated datasets were used for the specficity and sensitity parts of the study.  The hits to the test material genus represent hits to different species in the genus than the species reads were mapped to for the single organism datasets.  For all of the E. coli datasets reads were also mapped to the closely related genus Shigella as well as Citrobacter and an unclassified Enterobateriaceae.  
*Need to find a reference for genus level similarites for E coli genus hits*
```{r contam_counts_plot, fig.width=10, fig.height=4, echo=FALSE}
ggplot(contam_counts) + 
  geom_raster(aes(x = org2_name, y = match_genus, fill = match_genus), show_guide = F) + 
  facet_grid(~org1_name, scale = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90),
        axis.text = element_text(face = "italic"),
        strip.text.x = element_text(face="italic")) + 
  labs(x = "Contaminant Name", y= "Match Genus")
```

The method limit of detection ranged from 5 % to 0.000025 % of the sample(Fig. 5).  Most (31 out 42) of test material and contaminant combinations having limit of detection of 0.25 %.  F. tularensis and B. anthracis had consistently predicted limit of detection when spiked into other test materials.  The lower limit of detection is due to the lower geneic diversity of the two genus and therefore fewer reads in the datasest map uniquely to sequences for the genus.



```{r contam_LOD_plot, echo=FALSE}
ggplot(contam_genus_match) + 
  geom_raster(aes(y= as.factor(prop2), x = org2_tid, fill = match_genus)) + 
  facet_grid(.~org1_name, scale = "free_x") +
  labs(y = "Contaminant Spike Level", 
       x = "Contaminant", 
       fill = "Contaminant Genus") +
  theme_bw() +
  theme(strip.text = element_text(face="italic"), legend.position = "bottom", legend.direction="horizontal",axis.text.x = element_blank())
```

#### Things to add    
1. discussion of the accuracy of the estimated proportions (Final.Guess)     
2. Need to get numbers for the uniquely mapped reads   
3. size of the genomes    
4. proportion of reads in the datasets    

# Conclusions
The combination of whole genome sequencing and characterization of the datasets using pathoscope and a large reference database provides a viable method for characterizing test material purity.  Next steps are to apply this method to characterize existing microbial whole cell and genomic DNA test materials.  Future work could include characterization of the method performance for different read sizes and error profiles (e.g. Ion Torrent and Pacific Biosciences data).  Additionally, the reference database could be modified to include other common contaminants such as human mitochondria genome.  

# References
1.  Coursey, B. Framework for a Biothreat Field Response Mission Capability Framework for a Biothreat Field Response Mission Capability. 2011.
2.	ASTM, Standard Guide for operational guidelines for initial response to a suspected biothreat agent. ASTM International, 2008.
3.	Budowle, B., et al., Criteria for validation of methods in microbial forensics. Applied and environmental microbiology, 2008. 74: p. 5599-607.
4.	Coates, S.G., S.L. Brunelle, and M.G. Davenport, Development of standard method performance requirements for biological threat agent detection methods. Journal of AOAC International, 2011. 94: p. 1328-37.
5.	AOAC, AOAC SMPR 2010 . 002. 2011. p. 1342-1346.
6.	AOAC, AOAC SMPR 2010 . 001. 2011. p. 1338-1341.
7.	AOAC, AOAC SMPR 2010 . 003. 2011. p. 1347-1351.
8.	Shrestha, P.M., et al., When Is a Microbial Culture “ Pure ”? Persistent Cryptic Contaminant Escapes Detection Even with Deep Genome Sequencing. mBio, 2013. 4(3): p. e300591-12.
9.	Marron, A.O., M. Akam, and G. Walker, A Duplex PCR-Based Assay for Measuring the Amount of Bacterial Contamination in a Nucleic Acid Extract from a Culture of Free-Living Protists. PloS one, 2013. 8: p. e61732.
10.	Schmieder, R. and R. Edwards, Fast identification and removal of sequence contamination from genomic and metagenomic datasets. PloS one, 2011. 6: p. e17288.
11.	Zhou, Q., et al., QC-Chain: Fast and Holistic Quality Control Method for Next-Generation Sequencing Data. PLoS ONE, 2013. 8: p. e60234.
12.	Francis, O.E., et al., Pathoscope: Species identification and strain attribution with unassembled sequencing data. Genome research, 2013.
13.	Huang, W., et al., ART: a next-generation sequencing read simulator. Bioinformatics (Oxford, England), 2012. 28: p. 593-4.
14.	R Core Team. R: A language and environment for statistical computing. 2013, R Foundation for Statistical Computing: Vienna, Austria.
15.	Fukushima, M., K. Kakinuma, and R. Kawaguchi, Phylogenetic Analysis of Salmonella , Shigella , and Escherichia coli Strains on the Basis of the gyrB Gene Sequence Phylogenetic Analysis of Salmonella , Shigella , and Escherichia coli Strains on the Basis of the gyrB Gene Sequence. Journal of Clinical Microbiology, 2002. 40(8): p. 2779-2785.

# Acknowladgements
The authors would like to thanks Dr. Steven Lund for his assistance in developing the study.  The Department of Homeland Security (DHS) Science and Technology Directorate supported this work under the Interagency Agreement HSHQPM-12-X-00078 with the National Institute of Standards and Technology (NIST).  Opinions expressed in this paper are the authors’ and do not necessarily reflect the policies and views of DHS, NIST, or affiliated venues.  Certain commercial equipment, instruments, or materials are identified in this paper in order to specify the experimental procedure adequately.  Such identification is not intended to imply recommendations or endorsement by NIST, nor is it intended to imply that the materials or equipment identified are necessarily the best available for the purpose.  Official contribution of NIST; not subject to copyrights in USA.